# coding: utf-8
# Problem 36 「二種類の基数による回文数」

# 簡単な方針
#
# まず前提として、今回の設問はRubyの機能を駆使すれば簡単な問題である。
#  (1) 1~1000000までの間の回文数は、(1..1000000).select{|d| d.to_s == d.to_s.reverse}
# の計算で事足りるし、
# ここから2進数への変換と回文数となるもののみの取り出しも、ある数値の集合をSと置けば
#  (2) S.map{|d| d.to_s(2)}.select{|d| d == d.reverse}.map{|d| d.to_i(2)}
# の形でサクッと取り出せる。
# 
# しかし、2進数への変換は割と高コストであり、100万もの数値を一度に変換しようとすると約0.5秒かかる試算となる。
# 10万個で約0.05秒、1万個で0.005秒程度と考えると、ある程度(1)でコストをかけても(2)の変換を行う際の個数が減れば減るほど全体の計算時間は減ると考えられる。
#
# このことから、(1)の時点での候補を減らすことができないかを模索する。
#
# まず、「100万未満で10進でも2進でも回文数になるような数の総和を求めよ.」の一文から、2^0の位は必ずビットが立つため、対象となる数は奇数である。
# また、回文数が対象であることから、10進数表記の際の一番高い位の数も必ず奇数となる。
#
# このことを利用して、(1..(1000000/2)).map{|d| d*2-1}.select{|d| d == d.to_s.reverse.to_i}として数値の候補を絞ってみると、1100個まで絞られた。
# こうすると、(2)の計算コストはほぼほぼ0としてみなせるので、この集合から(2)の方法で数値を割り出す。

def euler036(num=1000000)
	num_set = (1..(num/2)).map{|d| d*2-1}.select{|d| d == d.to_s.reverse.to_i}
	num_set_b = num_set.map{|d| d.to_s(2)}.select{|d| d == d.reverse}.map{|d| d.to_i(2)}
	return num_set_b.inject(:+)
end
