# coding: utf-8
# Problem 32 「パンデジタル積」

# 簡単な方針
#
# 掛けられる数/掛ける数/積が1から9のパンデジジタルより、
# 掛けられる数=A、掛ける数=B、積=Cとして考えると、
# A*Bの桁+Cの桁=9でないといけない(※[1,2,3,4,5,6,7,8,9]の9つの数値の中からn個の数値を取りだすので)
# 
# この法則から考えるに、仮にAを固定して考えると、
# 例えば、Aがn桁である場合にはBは(n-1)桁かn桁増える可能性がある。(※例えば2桁の数値は最低でもBを10倍し、最大で99≒100倍する事から。)
# このことから、Cの桁数=(Aの桁数+Bの桁数) or Cの桁数=((Aの桁数-1)+Bの桁数)
# しかし、Aの桁数+Bの桁数+Cの桁数=9であるとすると、Cの桁数=(Aの桁数+Bの桁数)は、Aの桁数+Bの桁数+(Aの桁数+Bの桁数)=2*(Aの桁数+Bの桁数)=9となり、(Aの桁数+Bの桁数)が整数にならないので不適。
# よって、Cの桁数=((Aの桁数-1)+Bの桁数)となるので、Aの桁数+Bの桁数+Cの桁数=Aの桁数+Bの桁数+(Aの桁数-1+Bの桁数)=9 <=> 2*(Aの桁数+Bの桁数)=10 <=> (Aの桁数+Bの桁数)=5
# したがって、[Aの桁数,Bの桁数]=[1,4][2,3][3,2][4,1]のパターンのみを考えればよい。
# また、HINTより、n桁*m桁の計算結果とm桁*n桁の計算結果とを同一視して考えても良さそうなので、[1,4][2,3]の2パターンのみを考慮する。
#
# 以上から、次のような流れで問題を解く。
# index=[1,4][2,3]の2パターンにおいて、
# index[0]桁のAを構成する順列組み合わせと、index[1]桁のBを構成する順列組み合わせをそれぞれ求める。(※実質、その桁の数値を求めているのと同じ)
# AとBの順列組み合わせの個別の要素aとbに対して、
#  ・aとbに共通する要素があったら現在の処理をすっとばす
#  ・a*bが5桁を越えてしまうなら現在の処理をすっとばす
#  ・aとbとa*bの計算結果をばらしたものから0を抜いたもの、で和集合を作る。
#  ・和集合の大きさが9だった場合には題意を満たすので答えを格納する配列に入れる
#　・全計算が終了した後、答えを格納する配列内で値が重複している物を取り除いたうえで合計して出力する


def euler032
	num_set = [1,2,3,4,5,6,7,8,9]
	multiplied_index=[[1,4],[2,3]]
	ret = []
	multiplied_index.each do |arr|
		a_set = num_set.permutation(arr[0])
		b_set = num_set.permutation(arr[1])
		a_set.each do |a|
			b_set.each do |b|
				next if a&b != []
				ans = a.map{|d| d.to_s}.inject(:+).to_i * b.map{|d| d.to_s}.inject(:+).to_i
				next if Math.log10(ans).floor+1 > 4
				tmp = a | b | ans.to_s.split("").map{|d| d.to_i}.select{|e| e != 0}
				ret << ans if tmp.length == 9
			end
		end
	end
	return ret.uniq.inject(:+)
end
