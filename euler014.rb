# coding: utf-8
# Problem 14 「最長のコラッツ数列」

# 簡単な方針
# コラッツ数列は再現性があり、過去に登場した数値と全く同じ数値が計算途中で登場すればその後の計算を行う必要はない。
# つまり、コラッツ数列とはある数AとBのセット列で考えればよく、
# ex) 
# n=2:2→1 より、n=2の際のセット数は1
# n=3:3→10　より、n=3の際のセット数は10
# n=10:10→5　より、n=10の際のセット数は5
# ……といった感じで、ある数に対して対応するある数を求めれば良い
# n=5はこのあと5→16→8→4→2となるため、最終的にn=4ではn=2の数列がセットとなる。
# 
# この事から、以下の方針でコラッツ数列を最大にする数値を求める。
# (1)n=2において、コラッツ数列を求め、ハッシュにn=2の場合のコラッツ数列([2,1])を格納する。
# (2)n=3以上において、以下のアルゴリズムで処理。
#	(2-1)ハッシュ内にn=kが存在しない場合、コラッツ数列の処理を1手順すすめる
#	(2-2)ハッシュ内に1手順進めた際の数値jをキーとするデータがあるかを確認し、
#		・存在する場合：ハッシュにn=kの場合[k,n=jの場合の数値ないしは配列を平坦化したもの]
#		・存在しない場合：ハッシュにn=kの場合[k,j]を格納する
#	(2-3)これ以上計算が不可能になった時点で、ハッシュの中からまだ数値の格納されていない最も若い数値をnに代入して計算を続行
# (3)これを1～100万までの間、すべての数値が格納されるまで実行し、もっとも配列の要素数の多いnを取り出す

require 'prime'
def euler014(num=100)
	my_hash = {2 => [2,1]}
	tmp_arr = []
	3.upto(num) do |idx|
		if my_hash[idx] == nil then
			tmp_arr << idx
			tmp_idx = (idx % 2 == 0) ? idx/2 : 3*idx+1
			if my_hash[tmp_idx] == nil
				tmp_arr << tmp_idx
			else
				tmp_arr << my_hash[tmp_idx]
			end
			my_hash.store(idx, tmp_arr.flatten)
		end
		tmp_arr = []
		tmp_idx = 0
	end
	p my_hash.max_by{|d| d[1].length}
end